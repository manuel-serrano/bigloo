;; Copyright (c) 2025 Aghilas Y. Boussaa, see COPYING file

;; Print a CFG in graphviz's DOT format.

(module cfg_dump
   (import (ast_node  "Ast/node.scm")
           (type_type "Type/type.scm"))

   (from (cfg_node "Opt/CFG/node.scm"))

   (export (print-cfg-as-dot g::cfg)
           (generic dump-instr i::instruction n::long)
           (print-cfg-as-cfgwat g::cfg)))

(define-method (object-display obj::cfg-node . op)
   (let ((port (if (pair? op)
                   (car op)
                   (current-output-port))))
      (fprintf port "node_~a" (-fx 0 (-> obj idx)))))

(define-generic (dump-jump j::jump vis?::vector src::cfg-node))

(define (dump-types l::pair-nil)
   (for-each (lambda (t) (printf " ") (display-type-as-cfgwat t)) l))

(define (dump-arc src::cfg-node dst::cfg-node lab::bstring)
   (printf "\t~a -> ~a [label=\"~a :" src dst lab)
   (dump-types (-> dst intype))
   (printf "\"];\n"))

(define-method (dump-jump j::conditional vis?::vector src::cfg-node)
   (dump-arc src (-> j dst-true) "true")
   (dump-arc src (-> j dst-false) "false")
   (dump-node (-> j dst-false) vis?)
   (dump-node (-> j dst-true) vis?))

(define-method (dump-jump j::unconditional vis?::vector src::cfg-node)
   (dump-arc src (-> j dst) "")
   (dump-node (-> j dst) vis?))

(define-method (dump-jump j::on-cast vis?::vector src::cfg-node)
   (dump-arc src (-> j dst-cast) "cast")
   (dump-arc src (-> j dst-cast-fail) "cast fail")
   (dump-node (-> j dst-cast) vis?)
   (dump-node (-> j dst-cast-fail) vis?))

(define-method (dump-jump j::terminal vis?::vector src::cfg-node)
   (printf "\t~a -> return_~a [label=\"" src src)
   (display-instr-as-cfgwat (-> j i))
   (display "\"];\n"))

(define-generic (dump-instr i::instruction n::long)
   (display (make-string n #\space))
   (display (-> i opcode))
   (display "\n"))

(define-method (dump-instr i::one-arg n::long)
   (display (make-string n #\space))
   (display (-> i opcode))
   (display " ")
   (display-param-as-cfgwat (-> i x))
   (display "\n"))

(define-method (dump-instr i::two-args n::long)
   (display (make-string n #\space))
   (display (-> i opcode))
   (display " ")
   (display-param-as-cfgwat (-> i x))
   (display " ")
   (display-param-as-cfgwat (-> i y))
   (display "\n"))

(define-method (dump-instr i::three-args n::long)
   (display (make-string n #\space))
   (display (-> i opcode))
   (display " ")
   (display-param-as-cfgwat (-> i x))
   (display " ")
   (display-param-as-cfgwat (-> i y))
   (display " ")
   (display-param-as-cfgwat (-> i z))
   (display "\n"))

(define-method (dump-instr i::sequence n::long)
   (for-each (lambda (i) (dump-instr i (+fx 2 n))) (-> i body)))

(define-method (dump-instr i::block n::long)
   (display (make-string n #\space))
   (display "block")
   (dump-types (-> i intype))
   (display " --->")
   (dump-types (-> i outtype))
   (display "\n")
   (call-next-method)
   (display (make-string n #\space))
   (display "end\n"))

(define-method (dump-instr i::loop n::long)
   (display (make-string n #\space))
   (display "loop")
   (dump-types (-> i intype))
   (display " --->")
   (dump-types (-> i outtype))
   (display "\n")
   (call-next-method)
   (display (make-string n #\space))
   (display "end\n"))

(define-method (dump-instr i::if-then n::long)
   (display (make-string n #\space))
   (display "if")
   (dump-types (-> i intype))
   (display " --->")
   (dump-types (-> i outtype))
   (display "\n")
   (dump-instr (-> i then) n)
   (display (make-string n #\space))
   (display "end\n"))

(define-method (dump-instr i::if-else n::long)
   (display (make-string n #\space))
   (display "if")
   (dump-types (-> i intype))
   (display " --->")
   (dump-types (-> i outtype))
   (display "\n")
   (dump-instr (-> i then) n)
   (display (make-string n #\space))
   (display "else\n")
   (dump-instr (-> i else) n)
   (display (make-string n #\space))
   (display "end\n"))

(define (dump-node n::cfg-node vis?::vector)
   (unless (vector-ref vis? (-fx 0 (-> n idx)))
      (vector-set! vis? (-fx 0 (-> n idx)) #t)
      (printf "\t~a [shape=box, label=\"" n)
      (printf "~a\\l" n)
      (for-each (lambda (i) (display-instr-as-cfgwat i) (display "\\l")) (-> n body))
      (printf "\"];\n")
      (dump-jump (-> n end) vis? n)))

(define (print-cfg-as-dot g::cfg)
   (print "digraph CFG {")
   (let ((vis?::vector (make-vector (-> g size) #f)))
      (dump-node (-> g entry) vis?))
   (print "}"))

(define (display-type-as-cfgwat t)
   (match-case t
      ((ref null ?t)
       (display "(ref null ")
       (display-type-as-cfgwat t)
       (display ")"))
      ((ref ?t)
       (display "(ref ")
       (display-type-as-cfgwat t)
       (display ")"))
      ((? deftype?)
       (display (cer t)))
      ((? symbol?)
       (display t))
      (else (error "watib" "type not supported for printing" t))))

(define-generic (display-param-as-cfgwat p::parameter))

(define-method (display-param-as-cfgwat p::typep)
   (display-type-as-cfgwat (-> p type)))

(define-method (display-param-as-cfgwat p::idxp)
   (display (-> p idx)))

(define-method (display-param-as-cfgwat p::i32p)
   (display (-> p num)))

(define-method (display-param-as-cfgwat p::i64p)
   (display (-> p num)))

(define-method (display-param-as-cfgwat p::f32p)
   (display (-> p num)))

(define-method (display-param-as-cfgwat p::f64p)
   (display (-> p num)))

(define-generic (display-instr-as-cfgwat i::instruction)
   (printf "(~a)" (-> i opcode)))

(define-method (display-instr-as-cfgwat i::one-arg)
   (printf "(~a " (-> i opcode))
   (display-param-as-cfgwat (-> i x))
   (display ")"))

(define-method (display-instr-as-cfgwat i::two-args)
   (printf "(~a " (-> i opcode))
   (display-param-as-cfgwat (-> i x))
   (display " ")
   (display-param-as-cfgwat (-> i y))
   (display ")"))

(define-method (display-instr-as-cfgwat i::three-args)
   (printf "(~a " (-> i opcode))
   (display-param-as-cfgwat (-> i x))
   (display " ")
   (display-param-as-cfgwat (-> i y))
   (display " ")
   (display-param-as-cfgwat (-> i z))
   (display ")"))

(define-generic (display-end-as-cfgwat j::jump))

(define-method (display-end-as-cfgwat j::unconditional)
   (printf "(goto ~a)" (-> j dst)))

(define-method (display-end-as-cfgwat j::conditional)
   (printf "(if ~a ~a)" (-> j dst-true) (-> j dst-false)))

(define-method (display-end-as-cfgwat j::on-cast)
   (printf "(on-cast ~a ~a " (-> j dst-cast) (-> j dst-cast-fail))
   (display-type-as-cfgwat (-> j rt-src))
   (display " ")
   (display-type-as-cfgwat (-> j rt-dst))
   (display ")"))

(define-method (display-end-as-cfgwat j::terminal)
   (display "(terminal ")
   (display-instr-as-cfgwat (-> j i))
   (display ")"))

(define-method (display-end-as-cfgwat j::switch)
   (display "(switch")
   (for-each (lambda (n) (printf " ~a" n)) (-> j dsts))
   (display ")"))

(define (display-cfg-node-as-cfgwat n::cfg-node)
   (printf "(node ~a (param" n)
   (for-each (lambda (t) (display " ") (display-type-as-cfgwat t))
                (-> n intype))
   (display ")
   (body")
   (for-each (lambda (i) (display "\n    ") (display-instr-as-cfgwat i))
             (-> n body))
   (display ")
   (end ")
   (display-end-as-cfgwat (-> n end))
   (display "))\n\n"))

(define (print-cfg-as-cfgwat g::cfg)
   (with-access::func (-> g func) (type locals)
      (display "(cfg (param")
      (for-each (lambda (t) (display " ") (display-type-as-cfgwat t))
                (car type))
      (display ")
     (result")
      (for-each (lambda (t) (display " ") (display-type-as-cfgwat t))
                (cadr type))
      (display ")
     (local")
      (for-each (lambda (t) (display " ") (display-type-as-cfgwat t))
                locals)
      (printf ")
     (entry ~a))\n\n" (-> g entry))
      (for-each display-cfg-node-as-cfgwat (-> g rpostorder))))
