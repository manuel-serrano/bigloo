;; Copyright (c) 2025 Aghilas Y. Boussaa, see COPYING file

;; Opcodes table (section 5.4 of the specification).
;;
;; Opcodes are described in the format (opcode-text . opcode-binary), where
;; opcode-text is a symbol and opcode-binary a string.
;;
;; Not all opcodes are present here. Some instructions (such as ref.test) have
;; opcodes which depend on their arguments (testing for a nullable reference is
;; not the same opcode as testing for a non-nullable one for instance). Block
;; instructions are also not described here. Both of these kinds of instructions
;; are handled completely by the "Bin/binary.scm" file.

`((unreachable . "\x00")
  (nop         . "\x01")

  (throw . "\x08")

  (throw_ref . "\x0A")

  (br    . "\x0C")
  (br_if . "\x0D")

  (return . "\x0F")
  (call   . "\x10")

  (return_call . "\x12")

  (call_ref        . "\x14")
  (return_call_ref . "\x15")

  (br_on_null     . "\xD5")
  (br_on_non_null . "\xD6")

  (drop . "\x1A")

  (local.get  . "\x20")
  (local.set  . "\x21")
  (global.get . "\x23")
  (global.set . "\x24")

  (i32.const . "\x41")
  (i64.const . "\x42")
  (f32.const . "\x43")
  (f64.const . "\x44")

  (i32.eqz  . "\x45")
  (i32.eq   . "\x46")
  (i32.ne   . "\x47")
  (i32.lt_s . "\x48")
  (i32.lt_u . "\x49")
  (i32.gt_s . "\x4A")
  (i32.gt_u . "\x4B")
  (i32.le_s . "\x4C")
  (i32.le_u . "\x4D")
  (i32.ge_s . "\x4E")
  (i32.ge_u . "\x4F")

  (i64.eqz  . "\x50")
  (i64.eq   . "\x51")
  (i64.ne   . "\x52")
  (i64.lt_s . "\x53")
  (i64.lt_u . "\x54")
  (i64.gt_s . "\x55")
  (i64.gt_u . "\x56")
  (i64.le_s . "\x57")
  (i64.le_u . "\x58")
  (i64.ge_s . "\x59")
  (i64.ge_u . "\x5A")

  (f32.eq . "\x5B")
  (f32.ne . "\x5C")
  (f32.lt . "\x5D")
  (f32.gt . "\x5E")
  (f32.le . "\x5F")
  (f32.ge . "\x60")

  (f64.eq . "\x61")
  (f64.ne . "\x62")
  (f64.lt . "\x63")
  (f64.gt . "\x64")
  (f64.le . "\x65")
  (f64.ge . "\x66")

  (i32.clz    . "\x67")
  (i32.ctz    . "\x68")
  (i32.popcnt . "\x69")
  (i32.add    . "\x6A")
  (i32.sub    . "\x6B")
  (i32.mul    . "\x6C")
  (i32.div_s  . "\x6D")
  (i32.div_u  . "\x6E")
  (i32.rem_s  . "\x6F")
  (i32.rem_u  . "\x70")
  (i32.and    . "\x71")
  (i32.or     . "\x72")
  (i32.xor    . "\x73")
  (i32.shl    . "\x74")
  (i32.shr_s  . "\x75")
  (i32.shr_u  . "\x76")
  (i32.rotl   . "\x77")
  (i32.rotr   . "\x78")

  (i64.clz    . "\x79")
  (i64.ctz    . "\x7A")
  (i64.popcnt . "\x7B")
  (i64.add    . "\x7C")
  (i64.sub    . "\x7D")
  (i64.mul    . "\x7E")
  (i64.div_s  . "\x7F")
  (i64.div_u  . "\x80")
  (i64.rem_s  . "\x81")
  (i64.rem_u  . "\x82")
  (i64.and    . "\x83")
  (i64.or     . "\x84")
  (i64.xor    . "\x85")
  (i64.shl    . "\x86")
  (i64.shr_s  . "\x87")
  (i64.shr_u  . "\x89")
  (i64.rotl   . "\x8A")
  (i64.rotr   . "\x8B")

  (f32.abs      . "\x8B")
  (f32.neg      . "\x8C")
  (f32.ceil     . "\x8D")
  (f32.floor    . "\x8E")
  (f32.trunc    . "\x8F")
  (f32.nearest  . "\x90")
  (f32.sqrt     . "\x91")
  (f32.add      . "\x92")
  (f32.sub      . "\x93")
  (f32.mul      . "\x94")
  (f32.div      . "\x95")
  (f32.min      . "\x96")
  (f32.max      . "\x97")
  (f32.copysign . "\x98")

  (f64.abs      . "\x99")
  (f64.neg      . "\x9A")
  (f64.ceil     . "\x9B")
  (f64.floor    . "\x9C")
  (f64.trunc    . "\x9D")
  (f64.nearest  . "\x9E")
  (f64.sqrt     . "\x9F")
  (f64.add      . "\xA0")
  (f64.sub      . "\xA1")
  (f64.mul      . "\xA2")
  (f64.div      . "\xA3")
  (f64.min      . "\xA4")
  (f64.max      . "\xA5")
  (f64.copysign . "\xA6")

  (i32.wrap_i64        . "\xA7")
  (i32.trunc_f64_s     . "\xAA")
  (i32.trunc_f64_u     . "\xAB")
  (i64.extend_i32_s    . "\xAC")
  (i64.extend_i32_u    . "\xAD")
  (i64.trunc_f64_s     . "\xB0")
  (i64.trunc_f64_u     . "\xB1")
  (f32.convert_i32_s   . "\xB2")
  (f32.convert_i32_u   . "\xB3")
  (f32.convert_i64_s   . "\xB4")
  (f32.convert_i64_u   . "\xB5")
  (f32.demote_f64      . "\xB6")
  (f64.convert_i32_s   . "\xB7")
  (f64.convert_i32_u   . "\xB8")
  (f64.convert_i64_s   . "\xB9")
  (f64.convert_i64_u   . "\xBA")
  (f64.promote_f32     . "\xBB")
  (i32.reinterpret_f32 . "\xBC")
  (i64.reinterpret_f64 . "\xBD")
  (f32.reinterpret_i32 . "\xBE")
  (f64.reinterpret_i64 . "\xBF")

  (ref.null           . "\xD0")
  (ref.is_null        . "\xD1")
  (ref.func           . "\xD2")
  (ref.eq             . "\xD3")
  (ref.as_non_null    . "\xD4")
  (struct.new         . "\xFB\x00")
  (struct.new_default . "\xFB\x01")
  (struct.get         . "\xFB\x02")
  (struct.get_s       . "\xFB\x03")
  (struct.get_u       . "\xFB\x04")
  (struct.set         . "\xFB\x05")
  (array.new          . "\xFB\x06")

  (array.new_default . "\xFB\x07")
  (array.new_fixed   . "\xFB\x08")
  (array.new_data    . "\xFB\x09")
  (array.get         . "\xFB\x0B")
  (array.get_s       . "\xFB\x0C")
  (array.get_u       . "\xFB\x0D")
  (array.set         . "\xFB\x0E")
  (array.len         . "\xFB\x0F")
  (array.fill        . "\xFB\x10")
  (array.copy        . "\xFB\x11")

  (ref.i31   . "\xFB\x1C")
  (i31.get_s . "\xFB\x1D")
  (i31.get_u . "\xFB\x1E")

  ; we do not support offset/alignment yet, the opcodes contain the default
  ; value.
  (i32.load8_s . "\x2C\x00\x04")
  (i32.load8_u . "\x2D\x00\x04")
  (i32.store8  . "\x3A\x00\x04"))
